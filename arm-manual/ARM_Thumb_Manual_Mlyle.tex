\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[hidelinks,linktoc=all]{hyperref}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{amsmath}


\title{ARM-Thumb Machine Code Reference}
\author{Michael Lyle}
\date{2024 Edition}

\ttfamily

\usepackage[
  letterpaper,
  twoside,
  bindingoffset=1.1cm,
  inner=1.9cm,
  outer=1.9cm,
  top=2cm,
  bottom=2cm,
  headsep=1.2cm
]{geometry}

\usepackage[final]{pdfpages}
\usepackage{graphicx}
\usepackage{imakeidx}
\makeindex

\newcommand{\fullrule}{\\[-4pt]\noindent\rule{\textwidth}{1pt}\\}

\newcommand{\instruction}[5]{\addcontentsline{toc}{subsection}{#1}\vspace{0.8cm}\noindent \textbf{#1}\index{#5}\hspace*{\fill}\texttt{#3}\fullrule#2\vspace{0.25cm}\begin{center}#4\end{center}}

\newcommand{\hexnum}[2]{$\mathtt{#1}_{16}$ ($\mathtt{#2}_{10}$)}
\newcommand{\numtt}[1]{$\mathtt{#1}$}
\newcommand{\reg}[1]{$r#1$}

\setlength{\parskip}{6pt}%
\setlength{\parindent}{0pt}

\begin{document}

\maketitle
{
\setlength{\parskip}{0pt}%
\tableofcontents
}
\vspace{3.2cm}
\begin{center}
\includegraphics[width=5.2in]{computer_problems.png}

\scriptsize{XKCD \#722, "Computer Problems" (by Randall Munroe)}
\end{center}

\newpage

\section{Architecture Summary}

In this course, we will be learning ARM Thumb machine language.

Specifically, we are writing code for the ARMv7 Thumb architecture.  Its characteristics are:

\begin{itemize}
    \item \index{registers}32-bit (4 byte) register (word) size
    \item 32-bit (4 byte) address size
    \item 16-bit (2 byte) instruction length
    \item \index{address}Addresses point to individual bytes.  Instructions and words should be aligned in memory.
    \begin{itemize}
        \item An address pointing aligned with the beginning of a word will end in $0$, $4$, $8$, or $C$ in base $16$.
        \item An address pointing to an instruction will end in $0$, $2$, $4$, $6$, $8$, $A$, $C$, or $E$ in base $16$.
    \end{itemize}
    \item Instructions can access memory, or perform arithmetic, but not both (RISC / load-store machine).
    \item Eight general-purpose registers are easily accessed (\reg{0}-\reg{7}).
    \item Five additional general-purpose registers are more difficult to access (\reg{8}-\reg{12})
    \item Three special purpose registers (stack pointer, link register, and program counter)
    \item Capable ALU with hardware multiplier and standard flags:
    \begin{itemize}
        \item N (negative),
        \item Z (zero),
        \item C (carry),
        \item and V (overflow)
    \end{itemize}
\end{itemize}

\subsection{Machine Language vs. Assembly Language}

In this course, we are writing programs in machine language.  This is a raw sequence of numbers that tells the computer what to do.

\index{assembly}
One step up from machine language is to use assembly language, where each line of code corresponds to a single machine instruction, which the assembler then translates into the binary format of machine language.  Assemblers make the process of programming slightly easier by handling the details of instruction encoding and calculating addresses for the programmer.

Most contemporary programmers work with high-level languages, such as \textit{C}, \textit{Java}, or \textit{Python}. These languages require conversion to machine code for execution. This is typically done through compilation, where the high-level code is translated into machine code, or through interpretation, where another program executes the high-level code step-by-step.

\newpage

\section{Using the ARM Microprocessor Trainer}

You will be receiving an Microprocessor Trainer in this course. Before home computers were readily available, this was one way that many people learned to program. The Trainer has a keypad where you can inspect and manipulate the contents of memory, as well as run your program.

Unlike earlier trainers, the system designed for this class uses a modern instruction set, \textbf{ARM-Thumb}, which is still actively used on microcontrollers. It is closely related to the \textbf{ARM} instruction set used in modern phones, tablets, and Apple computers.

\begin{figure}[h]
    \includegraphics[width=13cm]{mptrainer.pdf}    
    \centering
    \caption{ARM Microprocessor Trainer, Revision B}
\end{figure}

If you've programmed before, this will be more cumbersome than you're used to! It's important to pre-plan your programs and think about what each instruction will do.

\subsection{Description of Keys}

\begin{itemize}
    \item \textbf{0-9, A-F}: Represent hexadecimal digits, which are used to enter numbers into the trainer.
    \item \textbf{CLR}: Functions as a backspace key, allowing you to correct any mistakes made during input.
    \item \textbf{ADDR}: Toggles the cursor between editing the memory address and the value at that address.
    \item \textbf{LOAD}: Loads the value located at the specified address into the display. Pressing this key repeatedly will advance the address sequentially, allowing you to view subsequent values.
    \item \textbf{STOR}: Saves the currently displayed value into the specified memory address, effectively writing data to memory. This will also advance the address.
    \item \textbf{STEP}: Executes the instruction at the current memory address and then automatically advances to the next address, facilitating step-by-step execution of your code.
    \item \textbf{RUN}: Starts a continuous execution of the program beginning at the current address. The execution will proceed without interruption until you press \textbf{STEP}.
\end{itemize}

\subsection{Screen Contents}
\index{screen}

The screen provides an overview of the current status of the microprocessor trainer.

\begin{figure}[h]
\begin{tikzpicture}
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}
    \node[anchor=south west,inner sep=0] (image) at (0,0) {\includegraphics[width=0.60\textwidth]{mptrainerscreen.png}};
    \begin{scope}[
        x={(image.south east)},
        y={(image.north west)}
    ]

    \node[shape=circle,draw,fill=white,inner sep=2pt,line width=2pt] at (0.4,0.36) {\huge$1$};
    \node[shape=circle,draw,fill=white,inner sep=2pt,line width=2pt] at (0.2,0.15) {\huge$2$};
    \node[shape=circle,draw,fill=white,inner sep=2pt,line width=2pt] at (0.55,0.15) {\huge$3$};
    \node[shape=circle,draw,fill=white,inner sep=2pt,line width=2pt] at (0.75,0.38) {\huge$4$};
    \node[shape=circle,draw,fill=white,inner sep=2pt,line width=2pt] at (0.6,0.78) {\huge$5$};

    \end{scope}
\end{tikzpicture}
\centering
\caption{Screen Contents at Startup}
\end{figure}

Various types of information are displayed on the screen:

\begin{enumerate}
\item \index{registers}The values of registers are displayed centrally.
\item The current address is displayed on the left.  A red arrow indicates we are currently editing the first digit of the address.
\item The value (that may be loaded or stored) is displayed to the right of the address.
\item The current flags (produced by the ALU and used by conditional branches) are displayed on the right side of the screen.
\item At the top of the screen is where a program's input/output is displayed.
\end{enumerate}

\subsection{Entering Instructions}

Once you have written your program and translated it into hexadecimal format, you will need to enter these instructions into the Microprocessor Trainer. Follow these steps to input each instruction:

\begin{enumerate}
    \item Turn on the Microprocessor Trainer and locate the keypad.
    \item Begin by setting the starting address where your program will be stored. Enter \texttt{20000000} using the numeric keys (0-9, A-F).
    \item Press the \textbf{ADDR} key to switch the focus from entering an address to entering a value.
    \item Now, enter the first instruction from your program. Remember, each instruction should be a 4-digit hexadecimal number (consisting of the characters 0-9 and A-F).
    \item After typing the hexadecimal instruction, press the \textbf{STOR} key. This will store your instruction at the current address. The Trainer will automatically advance to the next memory address.
    \item Repeat steps 4 and 5 for each subsequent instruction in your program:
        \begin{itemize}
            \item Enter the next 4-digit hexadecimal instruction.
\index{memory!store}
            \item Press the \textbf{STOR} key to store the instruction and move to the next address.
        \end{itemize}
    \item Continue this process until you have entered all the instructions of your program.
\end{enumerate}

Make sure you enter each instruction correctly and in the proper order. If you make a mistake, you can always go back to any address by entering it and pressing \textbf{ADDR} to correct the value.

\textbf{Tip:} Always double-check each instruction after entering it to make sure it has been input correctly before hitting \textbf{STOR}. This will save you time troubleshooting later!

\paragraph{Predicting Outcomes Before Execution:}
Before running your program, take a moment to predict the expected results and behavior of your code. For example, think about what values you expect to see in registers, and when. By anticipating the values in registers and the effects of each instruction, you can better identify when things might go wrong and understand why.

\subsection{Running a Program}

Once you have successfully entered all of your program's instructions into the Microprocessor Trainer, the next step is to run your program to see how it works.

\paragraph{Setting the Starting Point:}
\index{address}
First, you need to set the Trainer to the beginning of your program. Ensure the address field is active by pressing \textbf{ADDR} if necessary. Using the keypad, enter the address \texttt{20000000}, which is where your program starts. Finally, press the \textbf{ADDR} key to confirm the start address.

\paragraph{Choosing the Mode of Execution:}
With the starting address set, you have two options for running your program:
\begin{itemize}
    \item \textbf{Step-by-Step Execution:} If you want to see how each instruction is executed one at a time, press the \textbf{STEP} key. This allows you to observe the changes and understand the flow of your program in detail. After pressing \textbf{STEP}, the Trainer executes the current instruction and then pauses, waiting for you to press \textbf{STEP} again for the next instruction.

    \item \textbf{Continuous Execution:} If you prefer to run your program continuously from the start to the end, press the \textbf{RUN} key. The Trainer will execute all the instructions continuously until the end of the program is reached, or until you press the \textbf{STEP} key to halt execution.
\end{itemize}

\paragraph{Monitoring and Troubleshooting:}
As your program runs, watch the display on the Trainer to see the outputs and any changes in the values stored in the memory. If the program does not behave as expected, you may need to stop the execution, review and correct the instructions you entered. Remember, debugging is a normal part of learning to program.
\paragraph{Tip:} Start with the step-by-step execution mode when you’re testing a new program. It gives you a better understanding of how each part of your program works and helps in identifying and fixing any errors.

\subsection{Inspecting Memory}

After you run your program, or even while it is running, you might want to check what is happening inside the memory of the Microprocessor Trainer. This process is called "inspecting memory," and it lets you see the values stored in different memory locations. Here’s how you can do it:

\paragraph{Access the Memory:}
To look at the contents of a specific memory address, you need to first stop your program if it is running. You can do this by pressing the \textbf{STEP} key to pause execution.

\paragraph{Choosing the Address:}
Use the \textbf{ADDR} key to select the address field. Enter the desired memory address using the numeric keys (0-9, A-F). Remember that your program starts at \texttt{20000000}, so any addresses from this point onward may contain data or instructions from your program.

\paragraph{Loading the Value from Memory:}
\index{memory!load}
Once you have entered the desired address, press the \textbf{LOAD} key. This will load the value at the address you entered, and switch the cursor to the value field.

\subsection{Function Keys}

The \textbf{LOAD} key on the Microprocessor Trainer is not just for loading the value at the current address. When held down and used in combination with other keys, it activates a variety of special functions. Here's how you can use these combinations effectively:

\begin{itemize}
    \item \textbf{Keys 0 - 2}: \index{registers}Display different sets of registers on the screen. Pressing \textbf{LOAD} + \textbf{0} will show registers \texttt{r0} to \texttt{r3}, which is the default display.
    \item \textbf{Keys 4 - 6}: \index{saving}Save the currently entered program into internal flash memory. Each key represents a different storage slot, allowing for multiple programs to be stored simultaneously.
    \item \textbf{Keys 8 - A}:  \index{loading} Load previously saved programs from the corresponding slots in the internal flash memory. This is useful for retrieving and running stored code without re-entering it.
    \item \textbf{Key D}: \index{decimal} Toggle the display mode of the registers between hexadecimal and decimal. This can be helpful for easier reading or specific debugging needs.
    \item \textbf{Key F}: Activate a fast run mode, which executes the program without updating the display between each instruction. This mode allows for quicker execution but is generally not recommended for debugging, as changes in registers and memory are not visible in real time.
\end{itemize}

\subsection{The Easter Egg}
\index{snake}In your explorations with the Microprocessor Trainer, there's a special feature hidden for you to discover. This hidden feature, often called an "Easter egg," can be activated under specific conditions.

\paragraph{Hint:}
If you manage to load the ASCII values for the characters 'S', 'N', 'A', and 'K' into registers \texttt{r0} through \texttt{r3} respectively, and then execute a Supervisor Call (SVC) instruction code $\texttt{45}_{16}$ (which stands for 'E' in ASCII), something unexpected will happen!

\paragraph{Discover on Your Own:}
You might want to figure out how to achieve this setup and see what happens for yourself. It’s a fun way to apply what you’ve learned about ASCII values, registers, and supervisor calls.

\newpage

\section{ARM-Thumb Basic Instructions}

The following are just a few of the many instructions in the ARM-Thumb instruction set.  There are enough instructions in this manual to be able to write any program.  In other words, this set of instructions are Turing-complete.  But other instructions, not listed here, are often necessary to write the shortest and fastest possible program.

\instruction{ADD (add immediate)}{Add an 8 bit value (included in the instruction) to a register.  Flags are updated based on the result value.}{0011 0ddd iiii iiii}{$r[d] = r[d] + i$}{add}\index{immediate instructions}
\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{ddd} & (3 bits) & This is the register number of the operand to add to, \underline{and} the destination register where the result should be placed. \\
\texttt{iiii iiii} & (8 bits) & This is the value that should be added, included as an immediate operand in the instruction. \\
\end {tabular}

\vspace{0.5cm}


Examples:

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{0011 0ddd iiii iiii}&3???&Basic instruction encoding\\
\hline
\texttt{0011 0000 0000 0001}&3001&Adds the number \numtt{1} to \reg{0} \\
\hline
\texttt{0011 0011 0001 0010}&3312&Adds the number \hexnum{12}{18} to \reg{3} \\
\hline
\texttt{0011 0111 1010 0101}&37A5&Adds the number \hexnum{A5}{165} to \reg{7} \\
\hline

\end{tabular}


\instruction{ADD (add registers)}{Add two registers together, storing the result in a (optionally different) third register.  Flags are updated.}{0001 100m mmnn nddd}{$r[d] = r[m] + r[n]$}{add}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{mmm} & (3 bits) & This is the register number of the first operand to add. \\
\texttt{nnn} & (3 bits) & This is the register number of the second operand to add. \\
\texttt{ddd} & (3 bits) & This is the register number to store the result in. \\
\end {tabular}

\vspace{0.5cm}


Examples:

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{0001 100m mmnn nddd}&1???&Basic instruction encoding\\
\hline
\texttt{0001 1000 0000 0000}&1800&Adds \reg{0} to register \reg{0} and stores the result in \reg{0} (doubles \reg{0})\\
\hline
\texttt{0001 1000 0101 0011}&1853&Adds \reg{1} to \reg{2} and stores the result in \reg{3} \\
\hline
\texttt{0001 1000 1000 1011}&188B&Adds \reg{2} to \reg{1} and stores the result in \reg{3} (same as above)\\
\hline
\end{tabular}

\newpage
\instruction{B (branch)}{Branches the program counter to a new location.  (Goto a different part of your program)}{1110 0iii iiii iiii}{$pc = pc + 2*(i+2)$}{branch}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{iiiiiiii...} & (11 bits) & Number of instructions to jump forward (or backwards, if negative...)\\
\end {tabular}

\vspace{0.5cm}


Examples:

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1110 0iii iiii iiii}&E???&Basic instruction encoding\\
\hline
\texttt{1110 0111 1111 0000}&E7F0&Goes back to 14 instructions before this one.\\
\hline
\texttt{1110 0111 1111 0001}&E7F1&Goes back to 13 instructions before this one.\\
\hline
\texttt{1110 0111 1111 0010}&E7F2&Goes back to 12 instructions before this one.\\
\hline
\texttt{1110 0111 1111 1100}&E7FC&Goes back to 2 instructions before this one.\\
\hline
\texttt{1110 0111 1111 1101}&E7FD&Goes back to 1 instructions before this one.\\
\hline
\texttt{1110 0111 1111 1110}&E7FE&Goes to \textbf{THIS} instruction (infinite loop)\\
\hline
\texttt{1110 0111 1111 1111}&E7FF&Goes to the instruction after this one (does nothing)\\
\hline
\texttt{1110 0000 0000 0000}&E000&Skips 1 instruction after this one\\
\hline
\texttt{1110 0000 0000 0001}&E001&Skips 2 instructions after this one\\
\hline
\texttt{1110 0000 0000 0010}&E002&Skips 3 instructions after this one\\
\hline
\texttt{1110 0000 0000 1111}&E00F&Skips 16 instructions after this one\\
\hline
\end{tabular}

\instruction{CMP (compare registers)}{Subtracts one register from another and updates flags.  The result of the subtraction is thrown away. }{0100 0010 10mm mnnn}{$tmp = r[n] - r[m]$}{compare}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{nnn} & (3 bits) & This is the register number of the operand to subtract from. \\
\texttt{mmm} & (3 bits) & This is the register number of the subtrahend \\
\end{tabular}
\vspace{0.5cm}

Examples:

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{0100 0010 10mm mnnn}&42??&Basic instruction encoding\\
\hline
\texttt{0100 0010 1000 0001}&4281&Subtracts \reg{0} from register \reg{1} and updates flags \\
\hline
\texttt{0100 0010 1011 1110}&42BE&Subtracts \reg{7} from register \reg{6} and updates flags \\
\hline
\end{tabular}

\newpage
\instruction{MOV (move immediate)}{Moves a value, provided in the instruction, into a chosen register.}{0010 0ddd iiii iiii}{$r[d] = i$}{move}\index{immediate instructions}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{ddd} & (3 bits) & This is the register number where the result should be placed. \\
\texttt{iiii iiii} & (8 bits) & This is the value that should be placed into the destination register.  The high 24 bits of the register will be $0$ and the remaining 8 bits will be the immediate value. \\
\end {tabular}

\vspace{0.5cm}


Examples:

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{0010 0ddd iiii iiii}&2???&Basic instruction encoding\\
\hline
\texttt{0010 0000 0000 0000}&2000&Sets \reg{0} to the value \numtt{0}\\
\hline
\texttt{0010 0111 1111 1111}&27FF&Sets \reg{7} to the value \hexnum{FF}{255} \\
\hline
\texttt{0010 0010 0000 0101}&2205&Puts the number \numtt{5} in \reg{2} \\
\hline

\end{tabular}

\instruction{MOV (move register)}{Copies a value from one register to another.}{0100 0110 00mm mddd}{$r[d] = r[m]$}{move}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{mmm} & (3 bits) & This is the register number from which the value should be copied. \\
\texttt{ddd} & (3 bits) & This is the register number where the value should be placed.
\end{tabular}
\vspace{0.5cm}

Examples:

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{0100 0110 00mm mddd}&46??&Basic instruction encoding\\
\hline
\texttt{0100 0110 0000 1000}&4608&Sets \reg{0} to the value in \reg{1}\\
\hline
\texttt{0100 0110 0000 0001}&4601&Sets \reg{1} to the value in \reg{0}\\
\hline
\texttt{0100 0110 0011 1110}&463E&Sets \reg{6} to the value of \reg{7}\\
\hline
\end{tabular}

\newpage
\instruction{MUL (multiply registers)}{Multiplies register $n$ by register $d$, and stores the result in register $d$.}{0100 0011 01nn nddd}{$r[d] = r[d] * r[n]$}{multiply}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{nnn} & (3 bits) & This is the register number that contains the first number to be multiplied. \\
\texttt{ddd} & (3 bits) & This is the register number with the second multiplicand, and where the value should be placed.
\end{tabular}
\vspace{0.5cm}

Examples:


\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{0100 0011 01nn nddd}&43??&Basic instruction encoding\\
\hline
\texttt{0100 0011 0100 0000}&4340&Squares \reg{0} and puts the result back in \reg{0}\\
\hline
\texttt{0100 0011 0100 1000}&4348&Sets \reg{0} to \reg{1} times \reg{0}\\
\hline
\texttt{0100 0011 0100 0001}&4341&Sets \reg{1} to \reg{1} times \reg{0}\\
\hline
\texttt{0100 0011 0110 0011}&4363&Sets \reg{3} to \reg{3} times \reg{4}\\
\hline
\end{tabular}

\instruction{SUB (subtract immediate)}{Subtract an 8 bit value (included in the instruction) from a register.  Flags are updated based on the result value.}{0011 1ddd iiii iiii}{$r[d] = r[d] - i$}{subtract}\index{immediate instructions}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{ddd} & (3 bits) & This is the register number of the operand to subtract from, \underline{and} the destination register where the result should be placed. \\
\texttt{iiii iiii} & (8 bits) & This is the value that should be subtracted, included as an immediate operand in the instruction. \\
\end {tabular}

\vspace{0.5cm}


Examples:

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{0011 1ddd iiii iiii}&3???&Basic instruction encoding\\
\hline
\texttt{0011 1000 0000 0001}&3801&Subtracts the number \numtt{1} to \reg{0} \\
\hline
\texttt{0011 1011 0011 0001}&3B32&Subtracts the number \hexnum{32}{50} from \reg{3} \\
\hline
\texttt{0011 1111 1010 0101}&3FA5&Subtracts the number \hexnum{A5}{165} from \reg{7} \\
\hline

\end{tabular}

\newpage
\instruction{SUB (subtract registers)}{Subtract one register from another, storing the result in a (optionally different) third register.  Flags are updated.}{0001 101m mmnn nddd}{$r[d] = r[n] - r[m]$}{subtract}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{nnn} & (3 bits) & This is the register number of the operand to subtract. \\
\texttt{nnn} & (3 bits) & This is the register number of the operand to subtract from. \\
\texttt{ddd} & (3 bits) & This is the register number to store the result in. \\
\end {tabular}

\vspace{0.5cm}


Examples:

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{0001 101m mmnn nddd}&1???&Basic instruction encoding\\
\hline
\texttt{0001 1010 0000 0000}&1A00&Subtracts \reg{0} from register \reg{0} and stores the result in \reg{0} (sets \reg{0} to \numtt{0})\\
\hline
\texttt{0001 1010 0101 0011}&1A53&Subtracts \reg{1} from \reg{2} and stores the result in \reg{3} \\
\hline
\texttt{0001 1000 1000 1011}&1A8B&Subtracts \reg{2} from \reg{1} and stores the result in \reg{3} \\
\hline
\end{tabular}


\newpage
\section{ARM-Thumb Conditional Branches}

\instruction{BZ (branch if zero/equal)}{Branches the program counter to a new location, IF the Z flag is set.  This will branch if the result of the previous ALU operation was zero, or after using the CMP instruction on two equal values.  If the Z flag is not set, this instruction does nothing and execution continues at the next instruction.}{1101 0000 iiii iiii}{IF $Z$: $pc = pc + 2*(i+2)$}{branch!conditional}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{iiiiiiii} & (8 bits) & Number of instructions to jump forward (or backwards, if negative...)\\
\end {tabular}

\vspace{0.5cm}


Examples:

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1101 0000 iiii iiii}&D0??&Basic instruction encoding\\
\hline
\texttt{1101 0000 1111 0000}&D0F0&IF $Z$: Goes back to 14 instructions before this one.\\
\hline
\texttt{1101 0000 1111 0001}&D0F1&IF $Z$: Goes back to 13 instructions before this one.\\
\hline
\texttt{1101 0000 1111 0010}&D0F2&IF $Z$: Goes back to 12 instructions before this one.\\
\hline
\texttt{1101 0000 1111 1100}&D0FC&IF $Z$: Goes back to 2 instructions before this one.\\
\hline
\texttt{1101 0000 1111 1101}&D0FD&IF $Z$: Goes back to 1 instructions before this one.\\
\hline
\texttt{1101 0000 1111 1110}&D0FE&IF $Z$: Goes to \textbf{THIS} instruction (infinite loop if taken)\\
\hline
\texttt{1101 0000 1111 1111}&D0FF&IF $Z$: Goes to the instruction after this one (does nothing, either way)\\
\hline
\texttt{1101 0000 0000 0000}&D000&IF $Z$: Skips 1 instruction after this one\\
\hline
\texttt{1101 0000 0000 0001}&D001&IF $Z$: Skips 2 instructions after this one\\
\hline
\texttt{1101 0000 0000 0010}&D002&IF $Z$: Skips 3 instructions after this one\\
\hline
\texttt{1101 0000 0000 1111}&D00F&IF $Z$: Skips 16 instructions after this one\\
\hline
\end{tabular}

\newpage
\instruction{BNZ (branch if not zero/not equal)}{Branches the program counter to a new location, IF the Z flag is \textbf{not} set.  This will branch if the result of the previous ALU operation wasn't zero, or after using the CMP instruction on two inequal values.}{1101 0001 iiii iiii}{IF NOT $Z$: $pc = pc + 2*(i+2)$}{branch!conditional}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{iiiiiiii} & (8 bits) & Number of instructions to jump forward (or backwards, if negative...)\\
\end {tabular}

\vspace{0.5cm}


Examples:

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1101 0001 iiii iiii}&D1??&Basic instruction encoding\\
\hline
\texttt{1101 0001 1111 0000}&D1F0&IF NOT $Z$: Goes back to 14 instructions before this one.\\
\hline
\texttt{1101 0001 1111 0001}&D1F1&IF NOT $Z$: Goes back to 13 instructions before this one.\\
\hline
\texttt{1101 0001 1111 1101}&D1FD&IF NOT $Z$: Goes back to 1 instructions before this one.\\
\hline
\texttt{1101 0001 1111 1111}&D1FF&IF NOT $Z$: Goes to the instruction after this one (does nothing, either way)\\
\hline
\texttt{1101 0001 0000 0000}&D100&IF NOT $Z$: Skips 1 instruction after this one\\
\hline
\texttt{1101 0001 0000 0001}&D101&IF NOT $Z$: Skips 2 instructions after this one\\
\hline
\end{tabular}

\newpage
\instruction{BMI (branch if negative)}{Branches the program counter to a new location, IF the if the result of the previous ALU operation was less than zero, or after using the CMP instruction where the comparand is larger than the other value.}{1101 0100 iiii iiii}{IF $N$: $pc = pc + 2*(i+2)$}{branch!conditional}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{iiiiiiii} & (8 bits) & Number of instructions to jump forward (or backwards, if negative...)\\
\end {tabular}

\vspace{0.5cm}


Examples:

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1101 0100 iiii iiii}&D4??&Basic instruction encoding\\
\hline
\texttt{1101 0100 1111 0000}&D4F0&IF $N$: Goes back to 14 instructions before this one.\\
\hline
\texttt{1101 0100 1111 1101}&D4FD&IF $N$: Goes back to 1 instructions before this one.\\
\hline
\texttt{1101 0100 1111 1111}&D4FF&IF $N$: Goes to the instruction after this one (does nothing)\\
\hline
\texttt{1101 0100 0000 0000}&D400&IF $N$: Skips 1 instruction after this one\\
\hline
\end{tabular}

\vspace{3cm}

There are more conditional branches.  You can find information on how they are encoded in sections \ref{encodings} and \ref{condcodes}.

\newpage
\section{ARM-Thumb Miscellaneous Instructions}

\instruction{LSL (logical shift left, immediate)}{Shifts register $n$ left by a fixed number of bits, and stores the result in register $d$.}{0000 0iii iimm mddd}{$r[d] = r[m] << immediate$}{logical!shift}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{iiiii} & (5 bits) & \index{immediate instructions}This is the number of bits to shift the number left. \\
\texttt{mmm} & (3 bits) & This is the register number that contains the number to be shifted. \\
\texttt{ddd} & (3 bits) & This is the register number to store the result in.
\end{tabular}
\vspace{0.5cm}

Examples:


\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{0000 0iii iimm mddd}&0???&Basic instruction encoding\\
\hline
\texttt{0000 0000 0100 0000}&0040&Shifts \reg{0} one bit left (doubling it) and puts the result back in \reg{0}\\
\hline
\texttt{0000 0010 0010 0111}&0227&Shifts \reg{4} eight bits left (multiplying by 256) and puts the result in \reg{7}\\ 
\hline
\end{tabular}

\instruction{ORR (logical or, register)}{Computes the logical or operation of registers $m$ and $d$, and stores the result back in register $d$.}{0100 0011 00mm mddd}{$r[d] = r[m]$ logical-or $r[d]$}{logical!or}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{mmm} & (3 bits) & This is the register number that contains the first operand for logical-or. \\
\texttt{ddd} & (3 bits) & This is the register number that contains the second operand for logical-or, and the destination register to store the result within. \\
\end{tabular}
\vspace{0.5cm}

Examples:


\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{0100 0011 00mm mddd}&43??&Basic instruction encoding\\
\hline
\texttt{0100 0011 0000 1000}&4308&Ors \reg{1} with \reg{0} and stores the result in \reg{0}\\
\hline
\texttt{0100 0011 0010 1110}&432E&Ors \reg{5} with \reg{6} and stores the result in \reg{6}\\ 
\hline
\end{tabular}

\newpage
\instruction{AND (logical and, register)}{Computes the logical and operation of registers $m$ and $d$, and puts the result back in register $d$.}{0100 0000 00mm mddd}{$r[d] = r[m]$ logical-and $r[d]$}{logical!and}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{mmm} & (3 bits) & This is the register number that contains the first operand for logical-and. \\
\texttt{ddd} & (3 bits) & This is the register number that contains the second operand for logical-and, and the destination register to put the result within. \\
\end{tabular}
\vspace{0.5cm}

Examples:


\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{0100 0000 00mm mddd}&40??&Basic instruction encoding\\
\hline
\texttt{0100 0000 0000 1000}&4008&Ands \reg{1} with \reg{0} and stores the result in \reg{0}\\
\hline
\texttt{0100 0000 0010 1110}&402E&Ands \reg{5} with \reg{6} and stores the result in \reg{6}\\ 
\hline
\end{tabular}

\instruction{LDR (load register)}{Retrieves the word at the memory address formed from the sum of registers $m$ and $n$, and puts the result in register $t$.}{0101 100m mmnn nttt}{$r[t] = memory(r[m] + r[n])$}{memory!load}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{mmm} & (3 bits) & This is the first register that is combined to form the memory address. \\
\texttt{nnn} & (3 bits) & This is the second register that is combined to form the memory address. \\
\texttt{ttt} & (3 bits) & This is the target, where the word retrieved from memory is placed. \\
\end{tabular}
\vspace{0.5cm}

Examples:


\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{0101 100m mmnn nttt}&5???&Basic instruction encoding\\
\hline
\texttt{0101 1001 1100 0001}&59C1&Loads the value from address \reg{7} $+$ \reg{0} into \reg{1} \\
\hline
\end{tabular}

\newpage
\index{address}
\instruction{STR (store register)}{Forms a memory address by adding registers $m$ and $n$, and stores the contents of register $t$ at that location.}{0101 000m mmnn nttt}{$memory(r[m] + r[n]) = r[t]$}{memory!store}

\begin{tabular}{p{0.15\textwidth} p{0.10\textwidth} p{0.63\textwidth}}
\texttt{mmm} & (3 bits) & This is the first register that is combined to form the memory address. \\
\texttt{nnn} & (3 bits) & This is the second register that is combined to form the memory address. \\
\texttt{ttt} & (3 bits) & The contents of this register are stored to the chosen location in memory. \\
\end{tabular}
\vspace{0.5cm}

Examples:


\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{0101 000m mmnn nttt}&5???&Basic instruction encoding\\
\hline
\texttt{0101 0001 1100 0001}&51C1&Stores the value in \reg{1} to the  address \reg{7} $+$ \reg{0} \\
\hline
\end{tabular}

\newpage
\subsection{Logical Shifting (Illustrated)}

\begin{center}
\includegraphics[width=3.7in]{leftshift.eps}
\end{center}

\subsection{Putting a Large Value in a Register}

\index{address}
\index{memory!load}
\index{logical!shift}
\index{logical!or}
\index{move}
Often, it will be desirable to put a number larger than we can have in a single immediate into a register.  The immediate move instruction available to us only can place an $8$ bit value in a register, but registers are $32$ bits wide.

There are many ways to accomplish this, including using load instructions.  However, it can be complicated to calculate addresses.  Below is a simple method to place the value $12345678_{16}$ into \reg{0}, while using \reg{1} as a temporary space.

\renewcommand{\arraystretch}{1.5}
\begin{tabular}{p{0.1\textwidth} p{0.2\textwidth} p{0.6\textwidth}}

\texttt{20\underline{12}} & \texttt{MOV \reg{0}, $12_{16}$}&
Places the value $12_{16}$ into \reg{0}.\\

\texttt{0200} & \texttt{LSL \reg{0}, \reg{0}, \#8 }&
Shifts \reg{0} left 8 bits; it now contains $1200_{16}$.\\

\texttt{21\underline{34}} & \texttt{MOV \reg{1}, $34_{16}$}&
Puts $34_{16}$ into \reg{1}.\\

\texttt{4309} & \texttt{ORR \reg{0}, \reg{1}}&
Logical OR of \reg{0} and \reg{1}, putting the result in \reg{0}, which now contains $1234_{16}$.\\

\texttt{0200} & \texttt{LSL \reg{0}, \reg{0}, \#8 }&
Shifts \reg{0} left 8 bits; it now contains $123400_{16}$.\\

\texttt{21\underline{56}} & \texttt{MOV \reg{1}, $56_{16}$}&
Puts $56_{16}$ into \reg{1}.\\

\texttt{4309} & \texttt{ORR \reg{0}, \reg{1}}&
Logical OR of \reg{0} and \reg{1}, putting the result in \reg{0}, which now contains $123456_{16}$.\\

\texttt{0200} & \texttt{LSL \reg{0}, \reg{0}, \#8}&
Shifts register 0 left 8 bits; it now contains $12345600_{16}$.\\

\texttt{21\underline{78}} & \texttt{MOV \reg{1}, $78_{16}$}&
Puts $78_{16}$ into \reg{1}.\\

\texttt{4309} & \texttt{ORR \reg{0}, \reg{1}}&
Logical OR of \reg{0} and \reg{1}, putting the result in \reg{0}, which now contains $12345678_{16}$!\\
\end{tabular}
\renewcommand{\arraystretch}{1}


\vspace{0.5cm}
In this way, we can put large numbers into any of our registers.  This approach isn't terribly efficient: 10 instructions and 20 bytes are used to load a 4 byte word into a register, but it is simple and it works.




\newpage
\section{Special (SuperVisor Call) Instructions}

\index{supervisor call (SVC)}
Supervisor Call (SVC) instructions are special system-level operations that provide input/output (I/O) functionality and other system utilities. These instructions have been specifically configured for the computing environment used in this course.

Many of these expect for an appropriate value to be loaded to $r0$ (or other registers) before executing them.

\instruction{SVC00 (toggle LED)}{If the LED is off, this turns it on.  Otherwise, it turns the LED off.}{1101 1111 0000 0000}{}{LED}

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1101 1111 0000 0000}&DF00&Basic instruction encoding\\
\end{tabular}

\instruction{SVC01 (turn LED off)}{Turns the LED off.}{1101 1111 0000 0001}{}{LED}

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1101 1111 0000 0001}&DF01&Basic instruction encoding\\
\end{tabular}

\instruction{SVC02 (turn LED on)}{Turns the LED on.}{1101 1111 0000 0010}{}{LED}

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1101 1111 0000 0010}&DF02&Basic instruction encoding\\
\end{tabular}

\instruction{SVC03 (blink the LED)}{This slowly blinks the LED.  The value in $r0$ determines how many times the LED blinks.}{1101 1111 0000 0011}{}{LED}

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1101 1111 0000 0011}&DF03&Basic instruction encoding\\
\end{tabular}

\newpage

\instruction{SVC11 (sleep, tenths)}{This freezes the program for a short amount of time.  The length of time, in tenths of a second, is specified in $r0$.  For instance, if $r0$ is $15$, this will wait $1.5$ seconds before the program resumes running.}{1101 1111 0001 0001}{}{delay}

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1101 1111 0001 0001}&DF11&Basic instruction encoding\\
\end{tabular}

\instruction{SVC12 (sleep, seconds)}{This freezes the program for a short amount of time.  The length of time, in seconds, is specified in $r0$.  For instance, if $r0$ is $15$, this will wait $15$ seconds before the program resumes running.}{1101 1111 0001 0010}{}{delay}

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1101 1111 0001 0010}&DF12&Basic instruction encoding\\
\end{tabular}

\instruction{SVC20 (clear screen)}{This clears the top half of screen and positions the cursor to write out text at the upper left.}{1101 1111 0010 0000}{}{screen}

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1101 1111 0010 0010}&DF20&Basic instruction encoding\\
\end{tabular}

\instruction{SVC21 (output number, denary)}{This prints the number in $r0$ on the screen, as a base 10 (denary) number.  For instance, if $r0$ is $F_{16}$ (or $15_{10}$), this will write the number $15$ on the screen.}{1101 1111 0010 0001}{}{screen}

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1101 1111 0010 0001}&DF21&Basic instruction encoding\\
\end{tabular}

\newpage

\instruction{SVC22 (output number, hex)}{This prints the number in $r0$ on the screen, as a base 16 (hexadecimal) number.  For instance, if $r0$ is $F_{16}$ (or $15_{10}$), this will write $F$ on the screen.}{1101 1111 0010 0010}{}{screen}

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1101 1111 0010 0010}&DF22&Basic instruction encoding\\
\end{tabular}

\instruction{SVC23 (output ASCII character)}{This prints the character in $r0$ on the screen.  Only the last 8 bits of $r0$ are used.  For instance, if $r0$ is $4D_{16}$ (or $77_{10}$), this will write the character 'M' on the screen.  See the ASCII chart later in this guide for reference.}{1101 1111 0010 0011}{}{screen}

\index{ASCII}
\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1101 1111 0010 0011}&DF23&Basic instruction encoding\\
\end{tabular}

\newpage
\instruction{SVC24 (draw dot)}{This changes the color of one pixel on the screen.  The color to put in the pixel is stored as an 8 bit value in $r0$.  The coordinates to change are ($r1$, $r2$).}{1101 1111 0010 0100}{}{screen}

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1101 1111 0010 0100}&DF24&Basic instruction encoding\\
\end{tabular}

\index{screen}
\instruction{SVC25 (draw icon)}{This draws a 32 byte (16 halfword) icon  on the screen.  The icon is expected to immediately follow this instruction, and when the draw is complete the instruction pointer will be increased by $22_{16}$ to skip the icon data.  The color to draw the icon is stored as an 8 bit value in $r0$. The coordinates to draw the icon at are ($r1$, $r2$).}{1101 1111 0010 0101}{}{screen}

\index{icon}

\begin{tabular}{p{0.33\textwidth} p{0.09\textwidth} p{0.44\textwidth}}
\texttt{1101 1111 0010 0101}&DF25&Basic instruction encoding (32 bytes of icon data follow)\\
\end{tabular}

\index{colors}
\subsection{Screen Colors (8-bit)}

\textbf{SVC25} and \textbf{SVC24} take in \reg{0} an 8-bit color value.  This color value is formatted in the bit pattern \texttt{RRGG GBBB}, where \texttt{RR} is a two-bit value indicating the intensity of the color red, \texttt{GGG} is a three-bit value indicating the intensity of green, and \texttt{BBB} is a three-bit value indicating the intensity of the color blue.

For instance, if it's desired to draw an icon with the color purple, that requires bright red and bright blue, with no green.  Therefore, we will use the color \texttt{1100 0111} for full intensity red, no green, and full intensity blue.  This becomes the value $C7_{16}$ which can be placed into \reg{0} with the instruction \texttt{MOV R0, C7} encoded as \texttt{20C7}.

\subsection{Screen Coordinates}

Screen drawing routines also take in coordinates in (\reg{1}, \reg{2}).  Unlike graphing coordinates, as $y$ gets bigger this moves down the screen.  The upper left corner of the screen is at ($0$, $0$).  The upper right of the screen is at ($160$, $0$).  The lowest row that you should use on the screen is row $53$. Therefore, the bottom left and right corners of the screen are positioned at ($0$, $53$) and ($160$, $53$), respectively.

\section{Miscellaneous Reference}
\subsection{ASCII Character Map}
\index{ASCII}
\begin{center}
\input{ascii.tex}
\small{(modified by Michael Lyle, 2021)}
\end{center}

\newpage
\subsection{ARM Thumb Instruction Encoding}
\index{instruction encodings}
\label{encodings}
\vspace{0.5cm}
\includegraphics[width=\textwidth]{insencoding.eps}
Source: DDI0210, Arm Limited, 2004

\newpage
\subsubsection{CondCodes and Suffixes for Conditional Branches}
\label{condcodes}
\index{condition codes}
\includegraphics[width=\textwidth]{condcodesummary.eps}
Source: DDI0084D, Arm Limited, 1998

\newpage
\subsection{Hexadecimal and Decimal Conversion (Nybbles)}
\index{nybble}
\begin{table}[h]
\centering
\begin{minipage}[t]{0.48\textwidth}
\centering
\begin{tabular}{ccc}
\index{decimal}Decimal & \index{binary}Binary & \index{hexadecimal}Hexadecimal\\
\hline
$0$ & \texttt{0000} & $0$\\
$1$ & \texttt{0001} & $1$\\
$2$ & \texttt{0010} & $2$\\
$3$ & \texttt{0011} & $3$\\
$4$ & \texttt{0100} & $4$\\
$5$ & \texttt{0101} & $5$\\
$6$ & \texttt{0110} & $6$\\
$7$ & \texttt{0111} & $7$\\
\end{tabular}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.48\textwidth}
\centering
\begin{tabular}{ccc}
\index{decimal}Decimal & \index{binary}Binary & \index{hexadecimal}Hexadecimal\\
\hline
$8$ & \texttt{1000} & $8$\\
$9$ & \texttt{1001} & $9$\\
$10$ & \texttt{1010} & $A$\\
$11$ & \texttt{1011} & $B$\\
$12$ & \texttt{1100} & $C$\\
$13$ & \texttt{1101} & $D$\\
$14$ & \texttt{1110} & $E$\\
$15$ & \texttt{1111} & $F$\\
\end{tabular}
\end{minipage}
\end{table}

\index{branch!offsets}
\subsection{Branch Offsets (as used in B, BNZ, etc.)}
\begin{tabular}{p{0.30\textwidth} p{0.12\textwidth} p{0.23\textwidth} p{0.18\textwidth}}
Number of Instructions & Address Offset & 8 Bit Conditional Branch Offset & 11 Bit Branch Offset\\
\hline
Back 30 & $-3C_{16}$ & $E0_{16}$ & $7E0_{16}$ \\
Back 29 & $-3A_{16}$ & $E1_{16}$ & $7E1_{16}$ \\
...\\
Back 16 & $-20_{16}$ & $EE_{16}$ & $7EE_{16}$ \\
Back 15 & $-1E_{16}$ & $EF_{16}$ & $7EF_{16}$ \\
Back 14 & $-1C_{16}$ & $F0_{16}$ & $7F0_{16}$ \\
Back 13 & $-1A_{16}$ & $F1_{16}$ & $7F1_{16}$ \\
Back 12 & $-18_{16}$ & $F2_{16}$ & $7F2_{16}$ \\
...\\
Back 2 & $-4_{16}$ & $FC_{16}$ & $7FC_{16}$ \\
Back 1 & $-2_{16}$ & $FD_{16}$ & $7FD_{16}$ \\
Infinite Loop & $0$ & $FE_{16}$ & $7FE_{16}$ \\
Forward 1 (Do Nothing) & $+2_{16}$ & $FF_{16}$ & $7FF_{16}$ \\
Forward 2 (Skip 1) & $+4_{16}$ & $00_{16}$ & $000_{16}$ \\
Forward 3 (Skip 2) & $+6_{16}$ & $01_{16}$ & $001_{16}$ \\
...\\
Forward 15 (Skip 14) & $+1E_{16}$ & $0E_{16}$ & $00E_{16}$ \\
Forward 16 (Skip 15) & $+20_{16}$ & $0F_{16}$ & $00F_{16}$ \\
Forward 17 (Skip 16) & $+22_{16}$ & $10_{16}$ & $010_{16}$ \\
Forward 18 (Skip 17) & $+24_{16}$ & $11_{16}$ & $011_{16}$
\end{tabular}

\paragraph{General Equation for Branch Calculation:}
\( \text{Offset} = \frac{\text{Target} - \text{CurAddr}}{2} + 2 \)

\paragraph{Backwards Unconditional Branches:}
\( \text{Offset} = 800_{16} + \frac{\text{Target} - \text{CurAddr}}{2} - 2 \)

\paragraph{Backwards 8-bit Conditional Branches:}
\( \text{Offset} = 100_{16} + \frac{\text{Target} - \text{CurAddr}}{2} - 2 \)

\newpage
\addcontentsline{toc}{subsection}{ARM Thumb-16 Quick Reference Card}
\index{add}
\index{move}
\index{subtract}
\includepdf[angle=90,pages=1,pagecommand={},width=7.65in, offset=0.25in 0]{ThumbRefCard.pdf}
\index{memory!load}
\index{address}
\index{memory!store}
\index{branch}
\index{logical!and}
\index{logical!or}
\index{logical!shift}
\includepdf[angle=90,pages=2,pagecommand={},width=7.65in, offset=0.25in 0]{ThumbRefCard.pdf}
\index{supervisor call (SVC)}
\includepdf[angle=90,pages=3,pagecommand={},width=7.65in, offset=0.25in 0]{ThumbRefCard.pdf}

\addcontentsline{toc}{subsection}{CO\&D Program Form}
\includepdf[pages=1]{Program_Form.pdf}
\includepdf[pages=2]{Program_Form.pdf}
\addcontentsline{toc}{subsection}{CO\&D Execution Trace}
\includepdf[pages=3]{Program_Form.pdf}

\printindex

\vspace{0.5cm}
ARM-Thumb Machine Code Reference by Michael Lyle is licensed under Creative Commons Attribution 4.0 International. To view a copy of this license, visit \\
https://creativecommons.org/licenses/by/4.0/

\vspace{0.5cm}
The Thumb Quick Reference Card, and the instruction encoding information from DDI0210 and DDI0084D, copyright ARM Holdings.  The ASCII reference sheet is by Victor Eijkhout. The XKCD comic is by Randall Munroe.  The below comic, Captain Zilog, is from Zilog Corporation.  All rights for these documents remain with their respective authors.

\vspace{0.1cm}

\begin{figure}[h]
    \includegraphics[width=10.5cm]{zilog.png}    
    \centering
    \caption{From \textit{Captain Zilog}, 1979, Zilog, Inc.}
\end{figure}

\end{document}
